# Snapshot report for `src/patch.spec.ts`

The actual snapshot is saved in `patch.spec.ts.snap`.

Generated by [AVA](https://avajs.dev).

## Fix hang

> Snapshot 1

    `/*eslint sort-keys: "error"*/␊
    ␊
    /// <reference path="node_modules/tree-sitter-cli/dsl.d.ts" />␊
    const pluralize = require("pluralize");␊
    ␊
    /**␊
     * Returns the upper and lower cased versions of a keyword.␊
     * @param {string} keyword␊
     */␊
    function getCases(keyword) {␊
      const upper = keyword[0].toUpperCase() + keyword.slice(1);␊
      const lower = keyword[0].toLowerCase() + keyword.slice(1);␊
      return [upper, lower];␊
    }␊
    ␊
    /**␊
     * Returns the singular and plural versions of a keyword.␊
     * @param {string} keyword␊
     */␊
    function getQuantities(keyword) {␊
      return [pluralize.singular(keyword), pluralize.plural(keyword)];␊
    }␊
    ␊
    /**␊
     * Creates a rule for upper and lower case versions of a keyword.␊
     * Keywords may be multi-word tokens, e.g.: "double strike" becomes "Double strike" or "double strike".␊
     */␊
    const keyword = (string) => choice(...getCases(string));␊
    ␊
    /**␊
     * Create a rule matching a type name, like "card", or "land", or "creature", which accepts upper␊
     * or lowercase first letters, and pluralizes the pattern, e.g.: given sorcery it will accept:␊
     *   * sorcery␊
     *   * Sorcery␊
     *   * sorceries␊
     *   * Sorceries␊
     * @param {string} keyword␊
     */␊
    const typeName = (keyword) =>␊
      choice(...getQuantities(keyword).flatMap(getQuantities));␊
    ␊
    const repeat1Sep = (rule, separator) => seq(rule, repeat(seq(separator, rule)));␊
    ␊
    const keywordChoice = (...strings) => choice(...strings.map(keyword));␊
    ␊
    const typeNameChoice = (...strings) => choice(...strings.map(typeName));␊
    ␊
    module.exports = grammar({␊
      name: "mtg_oracle",␊
    ␊
      rules: {␊
        rules_line: ($) =>␊
          choice(␊
            $.keyword_ability_list,␊
            $.line_effect,␊
            $.line_activated_ability,␊
            $.line_static_ability␊
            // ... Definitions for other effect types ...␊
          ),␊
    ␊
        keyword_ability_list: ($) => repeat1Sep($.keyword_ability, ","),␊
    ␊
        line_effect: ($) => repeat1(seq($.effect, ".")),␊
        line_static_ability: ($) =>␊
          seq(␊
            $.static_ability_subject,␊
            optional(␊
              seq("have", optional("hexproof from"), $.static_ability_effect)␊
            )␊
          ),␊
    ␊
        static_ability_subject: ($) =>␊
          seq(␊
            optional($.continuous_tense_qualifier), // "All", "Each", "Every"␊
            $.subject_nontarget // Using the existing rule for subjects which are not targeted␊
          ),␊
    ␊
        static_ability_effect: ($) =>␊
          choice(␊
            $.keyword_ability, // Use the existing keyword_ability rule␊
            $.protection_qualifier, // Protection, as its own static ability effect␊
            $.keyword_ability_list // When multiple static abilities are granted␊
            // Additionally, new rules can be added if needed to handle other static effects␊
          ),␊
    ␊
        continuous_tense_qualifier: ($) => choice("all", "each", "every"),␊
    ␊
        effect: ($) => choice($.one_shot_effect),␊
    ␊
        line_activated_ability: ($) =>␊
          seq(␊
            $.cost, // Identify the cost of the ability␊
            ":", // Colon to separate cost from effect␊
            $.effect, // The effect that occurs as a result of the ability␊
            "."␊
          ),␊
    ␊
        keyword_ability: ($) =>␊
          choice(␊
            keywordChoice(␊
              "flying",␊
              "first strike",␊
              "lifelink",␊
              "vigilance",␊
              "deathtouch",␊
              "haste"␊
            ),␊
            $.keyword_ability_protection␊
          ),␊
    ␊
        // Definitions for one_shot_effect and its components␊
        one_shot_effect: ($) => seq($.action_verb, $.subject),␊
    ␊
        action_verb: ($) =>␊
          keywordChoice(␊
            // Using the keywordChoice helper␊
            "Exile",␊
            "Destroy",␊
            "Tap",␊
            "Untap",␊
            "Discard",␊
            "Sacrifice",␊
            "Create",␊
            "Counter",␊
            "Draw",␊
            "Scry",␊
            "Gain",␊
            "Add"␊
            // Some of these don't fit the pattern␊
          ),␊
    ␊
        subject: ($) => choice($.subject_target, $.subject_nontarget),␊
    ␊
        subject_target: ($) =>␊
          seq(␊
            optional($.finite_quantity), // "up to three", "another", "two"␊
            keyword("target"),␊
            repeat1($.qualifier) // Zero or many qualifiers like "creature", "with flying"␊
          ),␊
    ␊
        subject_nontarget: ($) =>␊
          seq(␊
            $.non_finite_quantity, // "all", "each", "every"␊
            repeat1($.qualifier) // At least one qualifier␊
          ),␊
    ␊
        finite_quantity: ($) => choice(seq("up to", $.number), "another", $.number),␊
    ␊
        non_finite_quantity: ($) => choice("all", "each", "every", "any number of"),␊
    ␊
        qualifier: ($) =>␊
          choice(␊
            $.qualifier_color,␊
            $.qualifier_supertype,␊
            $.qualifier_type,␊
            $.qualifier_control,␊
            $.subtype,␊
            $.modifier␊
          ),␊
    ␊
        qualifier_control: ($) =>␊
          /(\\byou\\b|\\byour\\b|\\bopponent's\\b)?\\s?\\bcontrol\\b/,␊
    ␊
        // Specific mana costs and tap/untap symbols␊
        mana_cost: ($) => seq("{", repeat1(choice(/[0-9A-Z]/, "T", "Q")), "}"),␊
        cost: ($) =>␊
          repeat1Sep(␊
            // Multiple costs are separated by commas␊
            choice(␊
              $.mana_cost, // Mana cost formatted as {1}, {G}, {2/U}, etc.␊
              "{T}", // Tapping symbol␊
              "{Q}", // Untapping symbol␊
              seq($.action_verb, $.subject), // Non-mana cost like "Sacrifice a creature"␊
              $.cost_life_payment // Paying life as a cost␊
              // Add other cost types if necessary and as they become available...␊
            ),␊
            "," // Costs can be separated by commas␊
          ),␊
    ␊
        cost_life_payment: ($) =>␊
          seq(␊
            "Pay", // The word "Pay"␊
            $.number, // The amount of life to pay␊
            "life" // The word "life"␊
          ),␊
    ␊
        qualifier_color: ($) =>␊
          keywordChoice("white", "blue", "black", "red", "green", "colorless"),␊
    ␊
        qualifier_supertype: ($) =>␊
          typeNameChoice("legendary", "basic", "snow", "world"),␊
    ␊
        qualifier_type: ($) =>␊
          typeNameChoice(␊
            "creature",␊
            "land",␊
            "artifact",␊
            "enchantment",␊
            "instant",␊
            "sorcery",␊
            "planeswalker"␊
          ),␊
    ␊
        subtype: ($) => $.any_subtype,␊
    ␊
        modifier: ($) =>␊
          seq(␊
            optional("with"),␊
            choice(␊
              keywordChoice("flying", "hexproof", "tapped", "untapped"),␊
              $.pt_modifier␊
            )␊
          ),␊
    ␊
        qualifier_pt: ($) => seq("with", $.pt_modifier),␊
    ␊
        pt_modifier: ($) =>␊
          seq(␊
            // Power/Toughness modifiers␊
            choice("+", "-"),␊
            $.number,␊
            "/",␊
            choice("+", "-"),␊
            $.number␊
          ),␊
    ␊
        keyword_ability_protection: ($) =>␊
          seq(keyword("protection"), "from", $.protection_qualifier),␊
    ␊
        protection_qualifier: ($) =>␊
          seq(␊
            choice(␊
              $.qualifier_color,␊
              keyword("multicolored"),␊
              keyword("everything"), // for protection from everything␊
              $.qualifier_type // This includes card types like artifacts or enchantments␊
              // Additional specific qualifiers if necessary...␊
            )␊
          ),␊
    ␊
        number: ($) => /[0-9]+/,␊
        any_subtype: ($) => /[A-Za-z-]+/, // More specific pattern would be ideal␊
      },␊
    });␊
    `
